<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mscdex/node-imap#readme"

    >imap (v0.8.19)</a>
</h1>
<h4>An IMAP module for node.js that makes communicating with IMAP servers easy</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.imap">module imap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.parseHeader">
            function <span class="apidocSignatureSpan">imap.</span>parseHeader
            <span class="apidocSignatureSpan">(str, noDecode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.super_">
            function <span class="apidocSignatureSpan">imap.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">imap.</span>Parser</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.imap.Parser">module imap.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.Parser.Parser">
            function <span class="apidocSignatureSpan">imap.</span>Parser
            <span class="apidocSignatureSpan">(stream, debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.Parser.parseBodyStructure">
            function <span class="apidocSignatureSpan">imap.Parser.</span>parseBodyStructure
            <span class="apidocSignatureSpan">(cur, literals, prefix, partID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.Parser.parseEnvelopeAddresses">
            function <span class="apidocSignatureSpan">imap.Parser.</span>parseEnvelopeAddresses
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.Parser.parseExpr">
            function <span class="apidocSignatureSpan">imap.Parser.</span>parseExpr
            <span class="apidocSignatureSpan">(o, literals, result, start, useBrackets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.imap.Parser.parseHeader">
            function <span class="apidocSignatureSpan">imap.Parser.</span>parseHeader
            <span class="apidocSignatureSpan">(str, noDecode)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.imap" id="apidoc.module.imap">module imap</a></h1>


    <h2>
        <a href="#apidoc.element.imap.parseHeader" id="apidoc.element.imap.parseHeader">
        function <span class="apidocSignatureSpan">imap.</span>parseHeader
        <span class="apidocSignatureSpan">(str, noDecode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseHeader(str, noDecode) {
  var lines = str.split(RE_CRLF),
      len = lines.length,
      header = {},
      state = {
        buffer: undefined,
        encoding: undefined,
        consecutive: false,
        replaces: undefined,
        curReplace: undefined,
        remainder: undefined
      },
      m, h, i, val;

  for (i = 0; i &#x3c; len; ++i) {
    if (lines[i].length === 0)
      break; // empty line separates message&#x27;s header and body
    if (lines[i][0] === &#x27;\t&#x27; || lines[i][0] === &#x27; &#x27;) {
      if (!Array.isArray(header[h]))
        continue; // ignore invalid first line
      // folded header content
      val = lines[i];
      if (!noDecode) {
        if (RE_ENCWORD_END.test(lines[i - 1])
            &#x26;&#x26; RE_ENCWORD_BEGIN.test(val)) {
          // RFC2047 says to *ignore* leading whitespace in folded header values
          // for adjacent encoded-words ...
          val = val.substring(1);
        }
      }
      header[h][header[h].length - 1] += val;
    } else {
      m = RE_HDR.exec(lines[i]);
      if (m) {
        h = m[1].toLowerCase().trim();
        if (m[2]) {
          if (header[h] === undefined)
            header[h] = [m[2]];
          else
            header[h].push(m[2]);
        } else
          header[h] = [&#x27;&#x27;];
      } else
        break;
    }
  }
  if (!noDecode) {
    var hvs;
    for (h in header) {
      hvs = header[h];
      for (i = 0, len = header[h].length; i &#x3c; len; ++i)
        hvs[i] = decodeWords(hvs[i], state);
    }
  }

  return header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prefix = &#x27;(#&#x27; + seqno + &#x27;) &#x27;;
msg.on(&#x27;body&#x27;, function(stream, info) {
  var buffer = &#x27;&#x27;;
  stream.on(&#x27;data&#x27;, function(chunk) {
    buffer += chunk.toString(&#x27;utf8&#x27;);
  });
  stream.once(&#x27;end&#x27;, function() {
    console.log(prefix + &#x27;Parsed header: %s&#x27;, inspect(Imap.<span class="apidocCodeKeywordSpan">parseHeader</span>(buffer
)));
  });
});
msg.once(&#x27;attributes&#x27;, function(attrs) {
  console.log(prefix + &#x27;Attributes: %s&#x27;, inspect(attrs, false, 8));
});
msg.once(&#x27;end&#x27;, function() {
  console.log(prefix + &#x27;Finished&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.imap.super_" id="apidoc.element.imap.super_">
        function <span class="apidocSignatureSpan">imap.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.imap.Parser" id="apidoc.module.imap.Parser">module imap.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.imap.Parser.Parser" id="apidoc.element.imap.Parser.Parser">
        function <span class="apidocSignatureSpan">imap.</span>Parser
        <span class="apidocSignatureSpan">(stream, debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(stream, debug) {
  if (!(this instanceof Parser))
    return new Parser(stream, debug);

  EventEmitter.call(this);

  this._stream = undefined;
  this._body = undefined;
  this._literallen = 0;
  this._literals = [];
  this._buffer = &#x27;&#x27;;
  this._ignoreReadable = false;
  this.debug = debug;

  var self = this;
  this._cbReadable = function() {
    if (self._ignoreReadable)
      return;
    if (self._literallen &#x3e; 0 &#x26;&#x26; !self._body)
      self._tryread(self._literallen);
    else
      self._tryread();
  };

  this.setStream(stream);

  process.nextTick(this._cbReadable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.imap.Parser.parseBodyStructure" id="apidoc.element.imap.Parser.parseBodyStructure">
        function <span class="apidocSignatureSpan">imap.Parser.</span>parseBodyStructure
        <span class="apidocSignatureSpan">(cur, literals, prefix, partID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseBodyStructure(cur, literals, prefix, partID) {
  var ret = [], i, len;
  if (prefix === undefined) {
    var result = (Array.isArray(cur) ? cur : parseExpr(cur, literals));
    if (result.length)
      ret = parseBodyStructure(result, literals, &#x27;&#x27;, 1);
  } else {
    var part, partLen = cur.length, next;
    if (Array.isArray(cur[0])) { // multipart
      next = -1;
      while (Array.isArray(cur[++next])) {
        ret.push(parseBodyStructure(cur[next],
                                    literals,
                                    prefix + (prefix !== &#x27;&#x27; ? &#x27;.&#x27; : &#x27;&#x27;)
                                           + (partID++).toString(), 1));
      }
      part = { type: cur[next++].toLowerCase() };
      if (partLen &#x3e; next) {
        if (Array.isArray(cur[next])) {
          part.params = {};
          for (i = 0, len = cur[next].length; i &#x3c; len; i += 2)
            part.params[cur[next][i].toLowerCase()] = cur[next][i + 1];
        } else
          part.params = cur[next];
        ++next;
      }
    } else { // single part
      next = 7;
      if (typeof cur[1] === &#x27;string&#x27;) {
        part = {
          // the path identifier for this part, useful for fetching specific
          // parts of a message
          partID: (prefix !== &#x27;&#x27; ? prefix : &#x27;1&#x27;),

          // required fields as per RFC 3501 -- null or otherwise
          type: cur[0].toLowerCase(), subtype: cur[1].toLowerCase(),
          params: null, id: cur[3], description: cur[4], encoding: cur[5],
          size: cur[6]
        };
      } else {
        // type information for malformed multipart body
        part = { type: cur[0] ? cur[0].toLowerCase() : null, params: null };
        cur.splice(1, 0, null);
        ++partLen;
        next = 2;
      }
      if (Array.isArray(cur[2])) {
        part.params = {};
        for (i = 0, len = cur[2].length; i &#x3c; len; i += 2)
          part.params[cur[2][i].toLowerCase()] = cur[2][i + 1];
        if (cur[1] === null)
          ++next;
      }
      if (part.type === &#x27;message&#x27; &#x26;&#x26; part.subtype === &#x27;rfc822&#x27;) {
        // envelope
        if (partLen &#x3e; next &#x26;&#x26; Array.isArray(cur[next]))
          part.envelope = parseFetchEnvelope(cur[next]);
        else
          part.envelope = null;
        ++next;

        // body
        if (partLen &#x3e; next &#x26;&#x26; Array.isArray(cur[next]))
          part.body = parseBodyStructure(cur[next], literals, prefix, 1);
        else
          part.body = null;
        ++next;
      }
      if ((part.type === &#x27;text&#x27;
           || (part.type === &#x27;message&#x27; &#x26;&#x26; part.subtype === &#x27;rfc822&#x27;))
          &#x26;&#x26; partLen &#x3e; next)
        part.lines = cur[next++];
      if (typeof cur[1] === &#x27;string&#x27; &#x26;&#x26; partLen &#x3e; next)
        part.md5 = cur[next++];
    }
    // add any extra fields that may or may not be omitted entirely
    parseStructExtra(part, partLen, cur, next);
    ret.unshift(part);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.imap.Parser.parseEnvelopeAddresses" id="apidoc.element.imap.Parser.parseEnvelopeAddresses">
        function <span class="apidocSignatureSpan">imap.Parser.</span>parseEnvelopeAddresses
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseEnvelopeAddresses(list) {
  var addresses = null;
  if (Array.isArray(list)) {
    addresses = [];
    var inGroup = false, curGroup;
    for (var i = 0, len = list.length, addr; i &#x3c; len; ++i) {
      addr = list[i];
      if (addr[2] === null) { // end of group addresses
        inGroup = false;
        if (curGroup) {
          addresses.push(curGroup);
          curGroup = undefined;
        }
      } else if (addr[3] === null) { // start of group addresses
        inGroup = true;
        curGroup = {
          group: addr[2],
          addresses: []
        };
      } else { // regular user address
        var info = {
          name: decodeWords(addr[0]),
          mailbox: addr[2],
          host: addr[3]
        };
        if (inGroup)
          curGroup.addresses.push(info);
        else if (!inGroup)
          addresses.push(info);
      }
      list[i] = addr;
    }
    if (inGroup) {
      // no end of group found, assume implicit end
      addresses.push(curGroup);
    }
  }
  return addresses;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.imap.Parser.parseExpr" id="apidoc.element.imap.Parser.parseExpr">
        function <span class="apidocSignatureSpan">imap.Parser.</span>parseExpr
        <span class="apidocSignatureSpan">(o, literals, result, start, useBrackets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpr(o, literals, result, start, useBrackets) {
  start = start || 0;
  var inQuote = false,
      lastPos = start - 1,
      isTop = false,
      isBody = false,
      escaping = false,
      val;

  if (useBrackets === undefined)
    useBrackets = true;
  if (!result)
    result = [];
  if (typeof o === &#x27;string&#x27;) {
    o = { str: o };
    isTop = true;
  }
  for (var i = start, len = o.str.length; i &#x3c; len; ++i) {
    if (!inQuote) {
      if (isBody) {
        if (o.str[i] === &#x27;]&#x27;) {
          val = convStr(o.str.substring(lastPos + 1, i + 1), literals);
          result.push(val);
          lastPos = i;
          isBody = false;
        }
      } else if (o.str[i] === &#x27;&#x22;&#x27;)
        inQuote = true;
      else if (o.str[i] === &#x27; &#x27;
               || o.str[i] === &#x27;)&#x27;
               || (useBrackets &#x26;&#x26; o.str[i] === &#x27;]&#x27;)) {
        if (i - (lastPos + 1) &#x3e; 0) {
          val = convStr(o.str.substring(lastPos + 1, i), literals);
          result.push(val);
        }
        if ((o.str[i] === &#x27;)&#x27; || (useBrackets &#x26;&#x26; o.str[i] === &#x27;]&#x27;)) &#x26;&#x26; !isTop)
          return i;
        lastPos = i;
      } else if ((o.str[i] === &#x27;(&#x27; || (useBrackets &#x26;&#x26; o.str[i] === &#x27;[&#x27;))) {
        if (o.str[i] === &#x27;[&#x27;
            &#x26;&#x26; i - 4 &#x3e;= start
            &#x26;&#x26; o.str.substring(i - 4, i).toUpperCase() === &#x27;BODY&#x27;) {
          isBody = true;
          lastPos = i - 5;
        } else {
          var innerResult = [];
          i = parseExpr(o, literals, innerResult, i + 1, useBrackets);
          lastPos = i;
          result.push(innerResult);
        }
      }
    } else if (o.str[i] === &#x27;\\&#x27;)
      escaping = !escaping;
    else if (o.str[i] === &#x27;&#x22;&#x27;) {
      if (!escaping)
        inQuote = false;
      escaping = false;
    }
    if (i + 1 === len &#x26;&#x26; len - (lastPos + 1) &#x3e; 0)
      result.push(convStr(o.str.substring(lastPos + 1), literals));
  }
  return (isTop ? result : start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.imap.Parser.parseHeader" id="apidoc.element.imap.Parser.parseHeader">
        function <span class="apidocSignatureSpan">imap.Parser.</span>parseHeader
        <span class="apidocSignatureSpan">(str, noDecode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseHeader(str, noDecode) {
  var lines = str.split(RE_CRLF),
      len = lines.length,
      header = {},
      state = {
        buffer: undefined,
        encoding: undefined,
        consecutive: false,
        replaces: undefined,
        curReplace: undefined,
        remainder: undefined
      },
      m, h, i, val;

  for (i = 0; i &#x3c; len; ++i) {
    if (lines[i].length === 0)
      break; // empty line separates message&#x27;s header and body
    if (lines[i][0] === &#x27;\t&#x27; || lines[i][0] === &#x27; &#x27;) {
      if (!Array.isArray(header[h]))
        continue; // ignore invalid first line
      // folded header content
      val = lines[i];
      if (!noDecode) {
        if (RE_ENCWORD_END.test(lines[i - 1])
            &#x26;&#x26; RE_ENCWORD_BEGIN.test(val)) {
          // RFC2047 says to *ignore* leading whitespace in folded header values
          // for adjacent encoded-words ...
          val = val.substring(1);
        }
      }
      header[h][header[h].length - 1] += val;
    } else {
      m = RE_HDR.exec(lines[i]);
      if (m) {
        h = m[1].toLowerCase().trim();
        if (m[2]) {
          if (header[h] === undefined)
            header[h] = [m[2]];
          else
            header[h].push(m[2]);
        } else
          header[h] = [&#x27;&#x27;];
      } else
        break;
    }
  }
  if (!noDecode) {
    var hvs;
    for (h in header) {
      hvs = header[h];
      for (i = 0, len = header[h].length; i &#x3c; len; ++i)
        hvs[i] = decodeWords(hvs[i], state);
    }
  }

  return header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prefix = &#x27;(#&#x27; + seqno + &#x27;) &#x27;;
msg.on(&#x27;body&#x27;, function(stream, info) {
  var buffer = &#x27;&#x27;;
  stream.on(&#x27;data&#x27;, function(chunk) {
    buffer += chunk.toString(&#x27;utf8&#x27;);
  });
  stream.once(&#x27;end&#x27;, function() {
    console.log(prefix + &#x27;Parsed header: %s&#x27;, inspect(Imap.<span class="apidocCodeKeywordSpan">parseHeader</span>(buffer
)));
  });
});
msg.once(&#x27;attributes&#x27;, function(attrs) {
  console.log(prefix + &#x27;Attributes: %s&#x27;, inspect(attrs, false, 8));
});
msg.once(&#x27;end&#x27;, function() {
  console.log(prefix + &#x27;Finished&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
